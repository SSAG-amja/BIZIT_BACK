from fastapi import APIRouter, HTTPException, status, Depends
from pydantic import BaseModel, EmailStr, Field
from motor.motor_asyncio import AsyncIOMotorClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jose import jwt, JWTError
import os
from core.config import users_collection

# --- 설정 (실제 환경에서는 .env 파일로 관리하세요) ---
SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM")
ACCESS_TOKEN_EXPIRE_MINUTES = os.geteev("ACCESS_TOKEN_EXPIRE_MINUTES")


# --- 보안 유틸리티 (비밀번호 해싱 & 토큰) ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# --- Pydantic 모델 (요청/응답 스키마) ---
class UserSignUp(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=4)
    username: str

class UserSignIn(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

# --- 라우터 정의 ---
router = APIRouter(prefix="/api/user", tags=["User"])

# 1. 회원가입 (Sign Up)
@router.post("/signup", status_code=status.HTTP_201_CREATED)
async def signup(user: UserSignUp):
    # 이메일 중복 확인
    existing_user = await user_collection.find_one({"email": user.email})
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="이미 등록된 이메일입니다."
        )

    # 비밀번호 해싱 및 저장
    hashed_password = get_password_hash(user.password)
    user_dict = user.dict()
    user_dict["password"] = hashed_password

    # DB 저장
    result = await user_collection.insert_one(user_dict)

    return {"message": "회원가입이 완료되었습니다.", "id": str(result.inserted_id)}

# 2. 로그인 (Sign In)
@router.post("/signin", response_model=Token)
async def signin(user: UserSignIn):
    # 사용자 조회
    db_user = await user_collection.find_one({"email": user.email})
    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="이메일 또는 비밀번호가 잘못되었습니다.",
        )

    # 비밀번호 검증
    if not verify_password(user.password, db_user["password"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="이메일 또는 비밀번호가 잘못되었습니다.",
        )

    # JWT 토큰 발급
    access_token = create_access_token(data={"sub": db_user["email"]})
    return {"access_token": access_token, "token_type": "bearer"}

# 3. 로그아웃 (Sign Out)
@router.post("/signout")
async def signout():
    """
    참고: JWT는 Stateless(무상태)이므로 서버에서 강제로 만료시킬 수 없습니다.
    클라이언트(프론트엔드)에서 저장된 토큰을 삭제하는 것이 실제 로그아웃입니다.
    더 강력한 로그아웃이 필요하다면 Redis 등을 이용해 토큰 블랙리스트를 구현해야 합니다.
    """
    return {"message": "로그아웃 되었습니다. 클라이언트에서 토큰을 삭제해주세요."}
